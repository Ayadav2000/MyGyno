 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/Dockerfile b/Dockerfile
index 4a4bed8774e53afca3332ef47f76dcbeaeb606a1..c4ba13ec99c27a21d91044c0e4ea3215b475ca7b 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,5 +1,15 @@
 FROM python:3.11-slim
+
 WORKDIR /app
-COPY . .
+
+ENV PYTHONDONTWRITEBYTECODE=1
+ENV PYTHONUNBUFFERED=1
+ENV PYTHONPATH=/app
+
+COPY requirements.txt .
+
 RUN pip install --no-cache-dir -r requirements.txt
-CMD ["gunicorn", "-b", "0.0.0.0:5000", "run:app"]
+
+COPY . .
+
+CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
diff --git a/README.md b/README.md
index 44e55fc8f81143afc8ad51e2cdd09513720a0b33..7beda622bcc2cdf7d08ca8e94bfce182976b8395 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,48 @@
 # MyGyno
-It is Gyno app for doctor and patient record plus there updtes
+
+MyGyno is a production-ready FastAPI backend for gynecology and women’s health workflows. It supports JWT authentication, role-based access control, patient profiles, cycle tracking, medical records, and secure chat.
+
+## Tech Stack
+
+- FastAPI (async)
+- SQLAlchemy 2.0 async ORM
+- PostgreSQL (production) / SQLite (local)
+- Alembic migrations
+- JWT authentication with refresh tokens
+
+## Quick Start
+
+### 1) Configure environment
+
+Create a `.env` file:
+
+```bash
+SECRET_KEY="change-me"
+DATABASE_URL="sqlite+aiosqlite:///./mygyno.db"
+```
+
+### 2) Run with Docker
+
+```bash
+docker-compose up --build app
+```
+
+The API is available at `http://localhost:8000`, with docs at `/docs`.
+
+## Testing (inside Docker)
+
+```bash
+./run_tests.sh
+```
+
+## API Modules
+
+- `/api/v1/auth` – register, login, refresh, password reset
+- `/api/v1/users` – user management
+- `/api/v1/patients` – patient profiles
+- `/api/v1/doctors` – doctor profiles and approvals
+- `/api/v1/cycles` – cycle tracking
+- `/api/v1/records` – medical records
+- `/api/v1/chat` – secure messaging
+- `/api/v1/admin` – admin stats
+- `/health` – health check
diff --git a/alembic.ini b/alembic.ini
new file mode 100644
index 0000000000000000000000000000000000000000..b1eca4a1b21fe8c16f6288a9ed050f49744ce45d
--- /dev/null
+++ b/alembic.ini
@@ -0,0 +1,35 @@
+[alembic]
+script_location = app/db/migrations
+sqlalchemy.url = sqlite+aiosqlite:///./mygyno.db
+
+[loggers]
+keys = root,sqlalchemy,alembic
+
+[handlers]
+keys = console
+
+[formatters]
+keys = generic
+
+[logger_root]
+level = WARN
+handlers = console
+
+[logger_sqlalchemy]
+level = WARN
+handlers = console
+qualname = sqlalchemy.engine
+
+[logger_alembic]
+level = INFO
+handlers = console
+qualname = alembic
+
+[handler_console]
+class = StreamHandler
+args = (sys.stderr,)
+level = NOTSET
+formatter = generic
+
+[formatter_generic]
+format = %(levelname)-5.5s [%(name)s] %(message)s
diff --git a/app/__init__.py b/app/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..4535d673290820143e6c4e1305d642f896f201eb
--- /dev/null
+++ b/app/__init__.py
@@ -0,0 +1,3 @@
+from app.main import app
+
+__all__ = ["app"]
diff --git a/app/api/deps.py b/app/api/deps.py
new file mode 100644
index 0000000000000000000000000000000000000000..5e2a0c0846e73c1ef5a96e2639eba150d551f2f4
--- /dev/null
+++ b/app/api/deps.py
@@ -0,0 +1,47 @@
+from fastapi import Depends, HTTPException, status
+from fastapi.security import OAuth2PasswordBearer
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.core.security import TokenError, decode_token
+from app.db.session import get_db
+from app.models.token_blacklist import TokenBlacklist
+from app.models.user import User, UserRole
+
+
+oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")
+
+
+async def get_current_user(
+    token: str = Depends(oauth2_scheme),
+    session: AsyncSession = Depends(get_db),
+) -> User:
+    try:
+        payload = decode_token(token)
+    except TokenError as exc:
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(exc)) from exc
+
+    if payload.get("type") != "access":
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token type")
+
+    jti = payload.get("jti")
+    if jti:
+        result = await session.execute(select(TokenBlacklist).where(TokenBlacklist.jti == jti))
+        if result.scalar_one_or_none():
+            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token revoked")
+
+    user_id = payload.get("sub")
+    result = await session.execute(select(User).where(User.id == user_id))
+    user = result.scalar_one_or_none()
+    if not user:
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not found")
+    return user
+
+
+def require_roles(*roles: UserRole):
+    async def _role_guard(current_user: User = Depends(get_current_user)) -> User:
+        if current_user.role not in roles:
+            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient permissions")
+        return current_user
+
+    return _role_guard
diff --git a/app/api/v1/__init__.py b/app/api/v1/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..c0384392dc6adb1f4b12e1f52690286f4df32fb9
--- /dev/null
+++ b/app/api/v1/__init__.py
@@ -0,0 +1,3 @@
+from app.api.v1 import admin, auth, chat, cycles, doctors, patients, records, users
+
+__all__ = ["admin", "auth", "chat", "cycles", "doctors", "patients", "records", "users"]
diff --git a/app/api/v1/admin.py b/app/api/v1/admin.py
new file mode 100644
index 0000000000000000000000000000000000000000..19184486a29b1e52218e0c28597039d6fdf73439
--- /dev/null
+++ b/app/api/v1/admin.py
@@ -0,0 +1,37 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import require_roles
+from app.db.session import get_db
+from app.models.doctor_profile import DoctorProfile
+from app.models.user import User, UserRole
+
+router = APIRouter(prefix="/admin", tags=["admin"])
+
+
+@router.get("/stats", dependencies=[Depends(require_roles(UserRole.admin))])
+async def system_stats(session: AsyncSession = Depends(get_db)) -> dict[str, int]:
+    result = await session.execute(select(User))
+    users = list(result.scalars().all())
+    return {
+        "total_users": len(users),
+        "patients": len([u for u in users if u.role == UserRole.patient]),
+        "doctors": len([u for u in users if u.role == UserRole.doctor]),
+        "admins": len([u for u in users if u.role == UserRole.admin]),
+    }
+
+
+@router.patch("/doctors/{doctor_id}/approve")
+async def approve_doctor(
+    doctor_id: str,
+    session: AsyncSession = Depends(get_db),
+    _: User = Depends(require_roles(UserRole.admin)),
+) -> dict[str, str]:
+    profile = await session.get(DoctorProfile, doctor_id)
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Doctor profile not found")
+    profile.is_approved = True
+    session.add(profile)
+    await session.commit()
+    return {"status": "approved"}
diff --git a/app/api/v1/auth.py b/app/api/v1/auth.py
new file mode 100644
index 0000000000000000000000000000000000000000..1b23642354bfb3b3c04c0d9c0416757dfe3bf66c
--- /dev/null
+++ b/app/api/v1/auth.py
@@ -0,0 +1,122 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from fastapi.security import OAuth2PasswordBearer
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import get_current_user
+from app.core.security import TokenError, decode_token
+from app.db.session import get_db
+from app.models.token_blacklist import TokenBlacklist
+from app.models.user import User
+from app.schemas.auth import (
+    LoginRequest,
+    PasswordResetConfirm,
+    PasswordResetRequest,
+    RefreshRequest,
+    Token,
+)
+from app.schemas.user import UserCreate, UserRead
+from app.services.auth import authenticate_user, build_tokens, create_user, get_user_by_email, revoke_token
+
+router = APIRouter(prefix="/auth", tags=["auth"])
+oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")
+
+
+@router.post("/register", response_model=UserRead, status_code=status.HTTP_201_CREATED)
+async def register(payload: UserCreate, session: AsyncSession = Depends(get_db)) -> User:
+    existing = await get_user_by_email(session, payload.email)
+    if existing:
+        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered")
+    user = await create_user(
+        session=session,
+        name=payload.name,
+        email=payload.email,
+        password=payload.password,
+        role=payload.role,
+        phone=payload.phone,
+    )
+    return user
+
+
+@router.post("/login", response_model=Token)
+async def login(payload: LoginRequest, session: AsyncSession = Depends(get_db)) -> Token:
+    user = await authenticate_user(session, payload.email, payload.password)
+    if not user:
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
+    access_token, refresh_token, _ = build_tokens(user)
+    return Token(access_token=access_token, refresh_token=refresh_token)
+
+
+@router.post("/refresh", response_model=Token)
+async def refresh(payload: RefreshRequest, session: AsyncSession = Depends(get_db)) -> Token:
+    try:
+        token_payload = decode_token(payload.refresh_token)
+    except TokenError as exc:
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(exc)) from exc
+
+    if token_payload.get("type") != "refresh":
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token type")
+
+    jti = token_payload.get("jti")
+    if jti:
+        result = await session.execute(select(TokenBlacklist).where(TokenBlacklist.jti == jti))
+        if result.scalar_one_or_none():
+            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token revoked")
+        await revoke_token(session, jti, "refresh")
+
+    user_id = token_payload.get("sub")
+    user = await session.get(User, user_id)
+    if not user:
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not found")
+
+    access_token, refresh_token, _ = build_tokens(user)
+    return Token(access_token=access_token, refresh_token=refresh_token)
+
+
+@router.post("/logout")
+async def logout(
+    token: str = Depends(oauth2_scheme),
+    current_user: User = Depends(get_current_user),
+    session: AsyncSession = Depends(get_db),
+) -> dict[str, str]:
+    try:
+        payload = decode_token(token)
+    except TokenError as exc:
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(exc)) from exc
+    jti = payload.get("jti")
+    if jti:
+        await revoke_token(session, jti, payload.get("type", "access"))
+    return {"message": f"{current_user.email} logged out"}
+
+
+@router.post("/password-reset")
+async def request_password_reset(
+    payload: PasswordResetRequest, session: AsyncSession = Depends(get_db)
+) -> dict[str, str]:
+    user = await get_user_by_email(session, payload.email)
+    if not user:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
+    access_token, _, _ = build_tokens(user)
+    return {"reset_token": access_token}
+
+
+@router.post("/password-reset/confirm")
+async def confirm_password_reset(
+    payload: PasswordResetConfirm, session: AsyncSession = Depends(get_db)
+) -> dict[str, str]:
+    try:
+        token_payload = decode_token(payload.token)
+    except TokenError as exc:
+        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(exc)) from exc
+
+    user_id = token_payload.get("sub")
+    user = await session.get(User, user_id)
+    if not user:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
+
+    from app.core.security import hash_password
+
+    user.hashed_password = hash_password(payload.new_password)
+    session.add(user)
+    await session.commit()
+    return {"message": "Password updated"}
diff --git a/app/api/v1/chat.py b/app/api/v1/chat.py
new file mode 100644
index 0000000000000000000000000000000000000000..11fcc704474176ae0d1d7ad8b318e0a34b5bbef2
--- /dev/null
+++ b/app/api/v1/chat.py
@@ -0,0 +1,46 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy import or_, select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import get_current_user
+from app.db.session import get_db
+from app.models.chat import ChatMessage
+from app.models.user import User
+from app.schemas.chat import ChatMessageCreate, ChatMessageRead
+
+router = APIRouter(prefix="/chat", tags=["chat"])
+
+
+@router.post("/send", response_model=ChatMessageRead)
+async def send_message(
+    payload: ChatMessageCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(get_current_user),
+) -> ChatMessage:
+    recipient = await session.get(User, payload.receiver_id)
+    if not recipient:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Recipient not found")
+    message = ChatMessage(
+        sender_id=current_user.id, receiver_id=payload.receiver_id, message=payload.message
+    )
+    session.add(message)
+    await session.commit()
+    await session.refresh(message)
+    return message
+
+
+@router.get("/history/{user_id}", response_model=list[ChatMessageRead])
+async def conversation(
+    user_id: str,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(get_current_user),
+) -> list[ChatMessage]:
+    result = await session.execute(
+        select(ChatMessage).where(
+            or_(
+                (ChatMessage.sender_id == current_user.id) & (ChatMessage.receiver_id == user_id),
+                (ChatMessage.sender_id == user_id) & (ChatMessage.receiver_id == current_user.id),
+            )
+        )
+    )
+    return list(result.scalars().all())
diff --git a/app/api/v1/cycles.py b/app/api/v1/cycles.py
new file mode 100644
index 0000000000000000000000000000000000000000..75a3a310a496fb5201ed8290de9a1f2e2f3c112c
--- /dev/null
+++ b/app/api/v1/cycles.py
@@ -0,0 +1,44 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import require_roles
+from app.db.session import get_db
+from app.models.cycle import CycleRecord
+from app.models.patient_profile import PatientProfile
+from app.models.user import User, UserRole
+from app.schemas.cycle import CycleCreate, CycleRead
+
+router = APIRouter(prefix="/cycles", tags=["cycles"])
+
+
+@router.post("/", response_model=CycleRead)
+async def create_cycle(
+    payload: CycleCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> CycleRecord:
+    result = await session.execute(
+        select(PatientProfile).where(PatientProfile.user_id == current_user.id)
+    )
+    profile = result.scalar_one_or_none()
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Profile not found")
+    cycle = CycleRecord(patient_profile_id=profile.id, **payload.model_dump())
+    session.add(cycle)
+    await session.commit()
+    await session.refresh(cycle)
+    return cycle
+
+
+@router.get("/me", response_model=list[CycleRead])
+async def list_my_cycles(
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> list[CycleRecord]:
+    result = await session.execute(
+        select(CycleRecord)
+        .join(PatientProfile)
+        .where(PatientProfile.user_id == current_user.id)
+    )
+    return list(result.scalars().all())
diff --git a/app/api/v1/doctors.py b/app/api/v1/doctors.py
new file mode 100644
index 0000000000000000000000000000000000000000..e015ce5c589df8bc800fc611fa10dae3e72ed3f7
--- /dev/null
+++ b/app/api/v1/doctors.py
@@ -0,0 +1,108 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import require_roles
+from app.db.session import get_db
+from app.models.doctor_profile import DoctorProfile
+from app.models.medical_record import MedicalRecord
+from app.models.patient_profile import PatientProfile
+from app.models.prescription import Prescription
+from app.models.user import User, UserRole
+from app.schemas.doctor import DoctorProfileCreate, DoctorProfileRead
+from app.schemas.patient import PatientProfileRead
+from app.schemas.prescription import PrescriptionCreate, PrescriptionRead
+from app.schemas.record import MedicalRecordCreate, MedicalRecordRead
+
+router = APIRouter(prefix="/doctors", tags=["doctors"])
+
+
+@router.post("/profile", response_model=DoctorProfileRead)
+async def create_doctor_profile(
+    payload: DoctorProfileCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.doctor)),
+) -> DoctorProfile:
+    existing = await session.execute(
+        select(DoctorProfile).where(DoctorProfile.user_id == current_user.id)
+    )
+    if existing.scalar_one_or_none():
+        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Profile already exists")
+    profile = DoctorProfile(user_id=current_user.id, **payload.model_dump(exclude={"is_approved"}))
+    session.add(profile)
+    await session.commit()
+    await session.refresh(profile)
+    return profile
+
+
+@router.get("/", response_model=list[DoctorProfileRead])
+async def list_doctors(session: AsyncSession = Depends(get_db)) -> list[DoctorProfile]:
+    result = await session.execute(select(DoctorProfile))
+    return list(result.scalars().all())
+
+
+@router.get("/patients", response_model=list[PatientProfileRead])
+async def assigned_patients(
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.doctor)),
+) -> list[PatientProfile]:
+    result = await session.execute(
+        select(DoctorProfile).where(DoctorProfile.user_id == current_user.id)
+    )
+    doctor_profile = result.scalar_one_or_none()
+    if not doctor_profile:
+        return []
+    result = await session.execute(
+        select(PatientProfile).where(PatientProfile.assigned_doctor_id == doctor_profile.id)
+    )
+    return list(result.scalars().all())
+
+
+@router.post("/records", response_model=MedicalRecordRead)
+async def add_medical_record(
+    payload: MedicalRecordCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.doctor)),
+) -> MedicalRecord:
+    result = await session.execute(
+        select(DoctorProfile).where(DoctorProfile.user_id == current_user.id)
+    )
+    doctor_profile = result.scalar_one_or_none()
+    if not doctor_profile or not doctor_profile.is_approved:
+        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Doctor not approved")
+    profile = await session.get(PatientProfile, payload.patient_id)
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient profile not found")
+    if profile.assigned_doctor_id and profile.assigned_doctor_id != doctor_profile.id:
+        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not assigned to patient")
+    record = MedicalRecord(
+        patient_profile_id=payload.patient_id,
+        doctor_id=doctor_profile.id,
+        **payload.model_dump(exclude={"patient_id"}),
+    )
+    session.add(record)
+    await session.commit()
+    await session.refresh(record)
+    return record
+
+
+@router.post("/prescriptions", response_model=PrescriptionRead)
+async def add_prescription(
+    payload: PrescriptionCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.doctor)),
+) -> Prescription:
+    result = await session.execute(
+        select(DoctorProfile).where(DoctorProfile.user_id == current_user.id)
+    )
+    doctor_profile = result.scalar_one_or_none()
+    if not doctor_profile or not doctor_profile.is_approved:
+        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Doctor not approved")
+    record = await session.get(MedicalRecord, payload.medical_record_id)
+    if not record or record.doctor_id != doctor_profile.id:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Medical record not found")
+    prescription = Prescription(**payload.model_dump())
+    session.add(prescription)
+    await session.commit()
+    await session.refresh(prescription)
+    return prescription
diff --git a/app/api/v1/patients.py b/app/api/v1/patients.py
new file mode 100644
index 0000000000000000000000000000000000000000..0126f024a7cf8b7e2065bc3e12ef97d70db24d40
--- /dev/null
+++ b/app/api/v1/patients.py
@@ -0,0 +1,166 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import get_current_user, require_roles
+from app.db.session import get_db
+from app.models.cycle import CycleRecord
+from app.models.doctor_profile import DoctorProfile
+from app.models.medical_history import MedicalHistory
+from app.models.medical_record import MedicalRecord
+from app.models.patient_profile import PatientProfile
+from app.models.user import User, UserRole
+from app.schemas.cycle import CycleCreate, CycleRead
+from app.schemas.medical_history import MedicalHistoryCreate, MedicalHistoryRead
+from app.schemas.patient import PatientProfileCreate, PatientProfileRead, PatientProfileUpdate
+from app.schemas.record import MedicalRecordRead
+
+router = APIRouter(prefix="/patients", tags=["patients"])
+
+
+@router.post("/profile", response_model=PatientProfileRead)
+async def create_profile(
+    payload: PatientProfileCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> PatientProfile:
+    existing = await session.execute(
+        select(PatientProfile).where(PatientProfile.user_id == current_user.id)
+    )
+    if existing.scalar_one_or_none():
+        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Profile already exists")
+    profile = PatientProfile(user_id=current_user.id, **payload.model_dump())
+    session.add(profile)
+    await session.commit()
+    await session.refresh(profile)
+    return profile
+
+
+@router.get("/profile/me", response_model=PatientProfileRead)
+async def get_my_profile(
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> PatientProfile:
+    result = await session.execute(
+        select(PatientProfile).where(PatientProfile.user_id == current_user.id)
+    )
+    profile = result.scalar_one_or_none()
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Profile not found")
+    return profile
+
+
+@router.patch("/profile/me", response_model=PatientProfileRead)
+async def update_my_profile(
+    payload: PatientProfileUpdate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> PatientProfile:
+    result = await session.execute(
+        select(PatientProfile).where(PatientProfile.user_id == current_user.id)
+    )
+    profile = result.scalar_one_or_none()
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Profile not found")
+    for key, value in payload.model_dump(exclude_unset=True).items():
+        setattr(profile, key, value)
+    session.add(profile)
+    await session.commit()
+    await session.refresh(profile)
+    return profile
+
+
+@router.get("/assigned", response_model=list[PatientProfileRead])
+async def get_assigned_patients(
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.doctor)),
+) -> list[PatientProfile]:
+    result = await session.execute(
+        select(DoctorProfile).where(DoctorProfile.user_id == current_user.id)
+    )
+    doctor_profile = result.scalar_one_or_none()
+    if not doctor_profile:
+        return []
+    result = await session.execute(
+        select(PatientProfile).where(PatientProfile.assigned_doctor_id == doctor_profile.id)
+    )
+    return list(result.scalars().all())
+
+
+@router.post("/{patient_id}/assign/{doctor_id}", response_model=PatientProfileRead)
+async def assign_doctor(
+    patient_id: str,
+    doctor_id: str,
+    session: AsyncSession = Depends(get_db),
+    _: User = Depends(require_roles(UserRole.admin)),
+) -> PatientProfile:
+    profile = await session.get(PatientProfile, patient_id)
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Profile not found")
+    doctor = await session.get(DoctorProfile, doctor_id)
+    if not doctor:
+        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Doctor not found")
+    profile.assigned_doctor_id = doctor_id
+    session.add(profile)
+    await session.commit()
+    await session.refresh(profile)
+    return profile
+
+
+@router.post("/history", response_model=MedicalHistoryRead)
+async def upsert_medical_history(
+    payload: MedicalHistoryCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> MedicalHistory:
+    result = await session.execute(
+        select(PatientProfile).where(PatientProfile.user_id == current_user.id)
+    )
+    profile = result.scalar_one_or_none()
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Profile not found")
+    result = await session.execute(
+        select(MedicalHistory).where(MedicalHistory.patient_profile_id == profile.id)
+    )
+    history = result.scalar_one_or_none()
+    if history:
+        for key, value in payload.model_dump(exclude_unset=True).items():
+            setattr(history, key, value)
+    else:
+        history = MedicalHistory(patient_profile_id=profile.id, **payload.model_dump())
+        session.add(history)
+    await session.commit()
+    await session.refresh(history)
+    return history
+
+
+@router.post("/cycles", response_model=CycleRead)
+async def add_cycle_record(
+    payload: CycleCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> CycleRecord:
+    result = await session.execute(
+        select(PatientProfile).where(PatientProfile.user_id == current_user.id)
+    )
+    profile = result.scalar_one_or_none()
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Profile not found")
+    record = CycleRecord(patient_profile_id=profile.id, **payload.model_dump())
+    session.add(record)
+    await session.commit()
+    await session.refresh(record)
+    return record
+
+
+@router.get("/records", response_model=list[MedicalRecordRead])
+async def list_patient_records(
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.patient)),
+) -> list[MedicalRecord]:
+    result = await session.execute(
+        select(MedicalRecord)
+        .join(PatientProfile)
+        .where(PatientProfile.user_id == current_user.id)
+    )
+    return list(result.scalars().all())
diff --git a/app/api/v1/records.py b/app/api/v1/records.py
new file mode 100644
index 0000000000000000000000000000000000000000..6a21f2c8bcf1ef5ba25f6781065a240daa213f9b
--- /dev/null
+++ b/app/api/v1/records.py
@@ -0,0 +1,67 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import get_current_user, require_roles
+from app.db.session import get_db
+from app.models.doctor_profile import DoctorProfile
+from app.models.medical_record import MedicalRecord
+from app.models.patient_profile import PatientProfile
+from app.models.user import User, UserRole
+from app.schemas.record import MedicalRecordCreate, MedicalRecordRead
+
+router = APIRouter(prefix="/records", tags=["records"])
+
+
+@router.post("/", response_model=MedicalRecordRead)
+async def create_record(
+    payload: MedicalRecordCreate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(require_roles(UserRole.doctor)),
+) -> MedicalRecord:
+    profile = await session.get(PatientProfile, payload.patient_id)
+    if not profile:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient profile not found")
+    result = await session.execute(
+        select(DoctorProfile).where(DoctorProfile.user_id == current_user.id)
+    )
+    doctor_profile = result.scalar_one_or_none()
+    if not doctor_profile or not doctor_profile.is_approved:
+        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Doctor not approved")
+    if profile.assigned_doctor_id and profile.assigned_doctor_id != doctor_profile.id:
+        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not assigned to patient")
+    record = MedicalRecord(
+        patient_profile_id=payload.patient_id,
+        doctor_id=doctor_profile.id,
+        **payload.model_dump(exclude={"patient_id"}),
+    )
+    session.add(record)
+    await session.commit()
+    await session.refresh(record)
+    return record
+
+
+@router.get("/me", response_model=list[MedicalRecordRead])
+async def list_my_records(
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(get_current_user),
+) -> list[MedicalRecord]:
+    if current_user.role == UserRole.patient:
+        result = await session.execute(
+            select(MedicalRecord)
+            .join(PatientProfile)
+            .where(PatientProfile.user_id == current_user.id)
+        )
+    elif current_user.role == UserRole.doctor:
+        result = await session.execute(
+            select(DoctorProfile).where(DoctorProfile.user_id == current_user.id)
+        )
+        doctor_profile = result.scalar_one_or_none()
+        if not doctor_profile:
+            return []
+        result = await session.execute(
+            select(MedicalRecord).where(MedicalRecord.doctor_id == doctor_profile.id)
+        )
+    else:
+        result = await session.execute(select(MedicalRecord))
+    return list(result.scalars().all())
diff --git a/app/api/v1/users.py b/app/api/v1/users.py
new file mode 100644
index 0000000000000000000000000000000000000000..079437b62cf42c659cc16c1bb466ca562a745e9d
--- /dev/null
+++ b/app/api/v1/users.py
@@ -0,0 +1,41 @@
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.api.deps import get_current_user, require_roles
+from app.db.session import get_db
+from app.models.user import User, UserRole
+from app.schemas.user import UserRead, UserUpdate
+
+router = APIRouter(prefix="/users", tags=["users"])
+
+
+@router.get("/me", response_model=UserRead)
+async def read_me(current_user: User = Depends(get_current_user)) -> User:
+    return current_user
+
+
+@router.get("/", response_model=list[UserRead], dependencies=[Depends(require_roles(UserRole.admin))])
+async def list_users(session: AsyncSession = Depends(get_db)) -> list[User]:
+    result = await session.execute(select(User))
+    return list(result.scalars().all())
+
+
+@router.patch("/{user_id}", response_model=UserRead)
+async def update_user(
+    user_id: str,
+    payload: UserUpdate,
+    session: AsyncSession = Depends(get_db),
+    current_user: User = Depends(get_current_user),
+) -> User:
+    if current_user.role != UserRole.admin and current_user.id != user_id:
+        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient permissions")
+    user = await session.get(User, user_id)
+    if not user:
+        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
+    for key, value in payload.model_dump(exclude_unset=True).items():
+        setattr(user, key, value)
+    session.add(user)
+    await session.commit()
+    await session.refresh(user)
+    return user
diff --git a/app/core/config.py b/app/core/config.py
new file mode 100644
index 0000000000000000000000000000000000000000..6fb9e5f2592490e1b73b63fb1ef396d4203dd989
--- /dev/null
+++ b/app/core/config.py
@@ -0,0 +1,3 @@
+from app.core.settings import settings
+
+__all__ = ["settings"]
diff --git a/app/core/security.py b/app/core/security.py
new file mode 100644
index 0000000000000000000000000000000000000000..f64581de2f85a6e11bd1456f75bc2be2d343fa1d
--- /dev/null
+++ b/app/core/security.py
@@ -0,0 +1,45 @@
+from datetime import datetime, timedelta, timezone
+from typing import Any
+from uuid import uuid4
+
+from jose import JWTError, jwt
+from passlib.context import CryptContext
+
+from app.core.settings import settings
+
+pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
+
+
+class TokenError(Exception):
+    pass
+
+
+def hash_password(password: str) -> str:
+    return pwd_context.hash(password)
+
+
+def verify_password(plain_password: str, hashed_password: str) -> bool:
+    return pwd_context.verify(plain_password, hashed_password)
+
+
+def create_token(subject: str, token_type: str, expires_delta: timedelta) -> tuple[str, str]:
+    now = datetime.now(timezone.utc)
+    expire = now + expires_delta
+    jti = str(uuid4())
+    payload: dict[str, Any] = {
+        "sub": subject,
+        "type": token_type,
+        "exp": expire,
+        "iat": now,
+        "jti": jti,
+    }
+    encoded = jwt.encode(payload, settings.secret_key, algorithm=settings.algorithm)
+    return encoded, jti
+
+
+def decode_token(token: str) -> dict[str, Any]:
+    try:
+        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])
+    except JWTError as exc:
+        raise TokenError("Invalid token") from exc
+    return payload
diff --git a/app/core/settings.py b/app/core/settings.py
new file mode 100644
index 0000000000000000000000000000000000000000..dafee8bd7cf729630558908d5edfdb26e8714621
--- /dev/null
+++ b/app/core/settings.py
@@ -0,0 +1,19 @@
+from pydantic import Field
+from pydantic_settings import BaseSettings, SettingsConfigDict
+
+
+class Settings(BaseSettings):
+    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
+
+    app_name: str = "MyGyno"
+    api_v1_prefix: str = "/api/v1"
+    environment: str = "development"
+    secret_key: str = Field("change-me", alias="SECRET_KEY")
+    access_token_expire_minutes: int = 30
+    refresh_token_expire_days: int = 7
+    algorithm: str = "HS256"
+    database_url: str = Field("sqlite+aiosqlite:///./mygyno.db", alias="DATABASE_URL")
+    cors_origins: list[str] = ["*"]
+
+
+settings = Settings()
diff --git a/app/db/base.py b/app/db/base.py
new file mode 100644
index 0000000000000000000000000000000000000000..fa2b68a5d245bbdde7fbea6b86c9650a584167d6
--- /dev/null
+++ b/app/db/base.py
@@ -0,0 +1,5 @@
+from sqlalchemy.orm import DeclarativeBase
+
+
+class Base(DeclarativeBase):
+    pass
diff --git a/app/db/migrations/env.py b/app/db/migrations/env.py
new file mode 100644
index 0000000000000000000000000000000000000000..9ab40f3b4229a86daef788c02e2aa53a95a7b006
--- /dev/null
+++ b/app/db/migrations/env.py
@@ -0,0 +1,73 @@
+from __future__ import annotations
+
+import asyncio
+from logging.config import fileConfig
+
+from alembic import context
+from sqlalchemy import pool
+from sqlalchemy.engine import Connection
+from sqlalchemy.ext.asyncio import async_engine_from_config
+
+from app.core.settings import settings
+from app.db.base import Base
+from app.models import (
+    chat,
+    cycle,
+    doctor_profile,
+    medical_history,
+    medical_record,
+    patient_profile,
+    prescription,
+    token_blacklist,
+    user,
+)
+
+config = context.config
+config.set_main_option("sqlalchemy.url", settings.database_url)
+
+if config.config_file_name is not None:
+    fileConfig(config.config_file_name)
+
+target_metadata = Base.metadata
+
+
+def run_migrations_offline() -> None:
+    context.configure(
+        url=settings.database_url,
+        target_metadata=target_metadata,
+        literal_binds=True,
+        dialect_opts={"paramstyle": "named"},
+    )
+
+    with context.begin_transaction():
+        context.run_migrations()
+
+
+def do_run_migrations(connection: Connection) -> None:
+    context.configure(connection=connection, target_metadata=target_metadata)
+
+    with context.begin_transaction():
+        context.run_migrations()
+
+
+async def run_migrations_online() -> None:
+    connectable = async_engine_from_config(
+        config.get_section(config.config_ini_section, {}),
+        prefix="sqlalchemy.",
+        poolclass=pool.NullPool,
+    )
+
+    async with connectable.connect() as connection:
+        await connection.run_sync(do_run_migrations)
+
+    await connectable.dispose()
+
+
+def run_migrations() -> None:
+    if context.is_offline_mode():
+        run_migrations_offline()
+    else:
+        asyncio.run(run_migrations_online())
+
+
+run_migrations()
diff --git a/app/db/migrations/versions/0001_initial.py b/app/db/migrations/versions/0001_initial.py
new file mode 100644
index 0000000000000000000000000000000000000000..dbd181df70d6a8c0c36625f0499e1b38d9ee772f
--- /dev/null
+++ b/app/db/migrations/versions/0001_initial.py
@@ -0,0 +1,181 @@
+"""initial schema
+
+Revision ID: 0001_initial
+Revises:
+Create Date: 2025-01-01 00:00:00.000000
+"""
+
+from alembic import op
+import sqlalchemy as sa
+
+
+revision = "0001_initial"
+down_revision = None
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    op.create_table(
+        "users",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("name", sa.String(length=200), nullable=False),
+        sa.Column("email", sa.String(length=255), nullable=False),
+        sa.Column("phone", sa.String(length=30)),
+        sa.Column("role", sa.Enum("patient", "doctor", "admin", name="userrole"), nullable=False),
+        sa.Column("hashed_password", sa.String(length=255), nullable=False),
+        sa.Column("is_active", sa.Boolean(), nullable=False, server_default=sa.text("true")),
+        sa.Column("is_verified", sa.Boolean(), nullable=False, server_default=sa.text("false")),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+    )
+    op.create_index("ix_users_email", "users", ["email"], unique=True)
+    op.create_index("ix_users_role", "users", ["role"])
+
+    op.create_table(
+        "doctor_profiles",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("user_id", sa.String(), nullable=False),
+        sa.Column("license_number", sa.String(length=120)),
+        sa.Column("specialization", sa.String(length=120)),
+        sa.Column("years_of_experience", sa.Integer()),
+        sa.Column("is_approved", sa.Boolean(), nullable=False, server_default=sa.text("false")),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+        sa.ForeignKeyConstraint(["user_id"], ["users.id"]),
+    )
+    op.create_index("ix_doctor_profiles_user_id", "doctor_profiles", ["user_id"], unique=True)
+
+    op.create_table(
+        "patient_profiles",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("user_id", sa.String(), nullable=False),
+        sa.Column("age", sa.Integer()),
+        sa.Column("height_cm", sa.Float()),
+        sa.Column("weight_kg", sa.Float()),
+        sa.Column("blood_group", sa.String(length=10)),
+        sa.Column("marital_status", sa.String(length=50)),
+        sa.Column("assigned_doctor_id", sa.String()),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+        sa.ForeignKeyConstraint(["user_id"], ["users.id"]),
+        sa.ForeignKeyConstraint(["assigned_doctor_id"], ["doctor_profiles.id"]),
+    )
+    op.create_index("ix_patient_profiles_user_id", "patient_profiles", ["user_id"], unique=True)
+    op.create_index("ix_patient_profiles_assigned_doctor_id", "patient_profiles", ["assigned_doctor_id"])
+
+    op.create_table(
+        "medical_histories",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("patient_profile_id", sa.String(), nullable=False),
+        sa.Column("obstetric_history", sa.String(length=200)),
+        sa.Column("menstrual_history", sa.Text()),
+        sa.Column("contraception_history", sa.Text()),
+        sa.Column("chronic_conditions", sa.Text()),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+        sa.ForeignKeyConstraint(["patient_profile_id"], ["patient_profiles.id"]),
+    )
+    op.create_index(
+        "ix_medical_histories_patient_profile_id",
+        "medical_histories",
+        ["patient_profile_id"],
+        unique=True,
+    )
+
+    op.create_table(
+        "cycle_records",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("patient_profile_id", sa.String(), nullable=False),
+        sa.Column("cycle_start_date", sa.Date(), nullable=False),
+        sa.Column("cycle_end_date", sa.Date()),
+        sa.Column("cycle_length", sa.Integer()),
+        sa.Column("flow_intensity", sa.String(length=50)),
+        sa.Column("symptoms", sa.String(length=255)),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+        sa.ForeignKeyConstraint(["patient_profile_id"], ["patient_profiles.id"]),
+    )
+    op.create_index("ix_cycle_records_patient_profile_id", "cycle_records", ["patient_profile_id"])
+
+    op.create_table(
+        "medical_records",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("patient_profile_id", sa.String(), nullable=False),
+        sa.Column("doctor_id", sa.String(), nullable=False),
+        sa.Column("diagnosis", sa.String(length=255)),
+        sa.Column("notes", sa.String(length=500)),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+        sa.ForeignKeyConstraint(["patient_profile_id"], ["patient_profiles.id"]),
+        sa.ForeignKeyConstraint(["doctor_id"], ["doctor_profiles.id"]),
+    )
+    op.create_index("ix_medical_records_patient_profile_id", "medical_records", ["patient_profile_id"])
+    op.create_index("ix_medical_records_doctor_id", "medical_records", ["doctor_id"])
+
+    op.create_table(
+        "prescriptions",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("medical_record_id", sa.String(), nullable=False),
+        sa.Column("medication_name", sa.String(length=255), nullable=False),
+        sa.Column("dosage", sa.String(length=120), nullable=False),
+        sa.Column("frequency", sa.String(length=120), nullable=False),
+        sa.Column("duration", sa.String(length=120), nullable=False),
+        sa.ForeignKeyConstraint(["medical_record_id"], ["medical_records.id"]),
+    )
+    op.create_index("ix_prescriptions_medical_record_id", "prescriptions", ["medical_record_id"])
+
+    op.create_table(
+        "chat_messages",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("sender_id", sa.String(), nullable=False),
+        sa.Column("receiver_id", sa.String(), nullable=False),
+        sa.Column("message", sa.String(length=1000), nullable=False),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+        sa.ForeignKeyConstraint(["sender_id"], ["users.id"]),
+        sa.ForeignKeyConstraint(["receiver_id"], ["users.id"]),
+    )
+    op.create_index("ix_chat_messages_sender_id", "chat_messages", ["sender_id"])
+    op.create_index("ix_chat_messages_receiver_id", "chat_messages", ["receiver_id"])
+    op.create_index(
+        "ix_chat_messages_sender_receiver", "chat_messages", ["sender_id", "receiver_id"]
+    )
+
+    op.create_table(
+        "token_blacklist",
+        sa.Column("id", sa.String(), primary_key=True),
+        sa.Column("jti", sa.String(length=64), nullable=False),
+        sa.Column("token_type", sa.String(length=20), nullable=False),
+        sa.Column("revoked", sa.Boolean(), nullable=False, server_default=sa.text("true")),
+        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
+        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
+    )
+    op.create_index("ix_token_blacklist_jti", "token_blacklist", ["jti"], unique=True)
+
+
+def downgrade() -> None:
+    op.drop_index("ix_token_blacklist_jti", table_name="token_blacklist")
+    op.drop_table("token_blacklist")
+    op.drop_index("ix_chat_messages_receiver_id", table_name="chat_messages")
+    op.drop_index("ix_chat_messages_sender_id", table_name="chat_messages")
+    op.drop_index("ix_chat_messages_sender_receiver", table_name="chat_messages")
+    op.drop_table("chat_messages")
+    op.drop_index("ix_prescriptions_medical_record_id", table_name="prescriptions")
+    op.drop_table("prescriptions")
+    op.drop_index("ix_medical_records_doctor_id", table_name="medical_records")
+    op.drop_index("ix_medical_records_patient_profile_id", table_name="medical_records")
+    op.drop_table("medical_records")
+    op.drop_index("ix_cycle_records_patient_profile_id", table_name="cycle_records")
+    op.drop_table("cycle_records")
+    op.drop_index("ix_medical_histories_patient_profile_id", table_name="medical_histories")
+    op.drop_table("medical_histories")
+    op.drop_index("ix_patient_profiles_assigned_doctor_id", table_name="patient_profiles")
+    op.drop_index("ix_patient_profiles_user_id", table_name="patient_profiles")
+    op.drop_table("patient_profiles")
+    op.drop_index("ix_doctor_profiles_user_id", table_name="doctor_profiles")
+    op.drop_table("doctor_profiles")
+    op.drop_index("ix_users_role", table_name="users")
+    op.drop_index("ix_users_email", table_name="users")
+    op.drop_table("users")
+    op.execute("DROP TYPE userrole")
diff --git a/app/db/session.py b/app/db/session.py
new file mode 100644
index 0000000000000000000000000000000000000000..3d53d2a140a767e4887023b792aaea71a3e2bdb8
--- /dev/null
+++ b/app/db/session.py
@@ -0,0 +1,13 @@
+from collections.abc import AsyncGenerator
+
+from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
+
+from app.core.settings import settings
+
+engine = create_async_engine(settings.database_url, future=True, echo=False)
+AsyncSessionLocal = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)
+
+
+async def get_db() -> AsyncGenerator[AsyncSession, None]:
+    async with AsyncSessionLocal() as session:
+        yield session
diff --git a/app/main.py b/app/main.py
new file mode 100644
index 0000000000000000000000000000000000000000..0fe30dbfb3c5cb9741b8d6db7880c32936356d92
--- /dev/null
+++ b/app/main.py
@@ -0,0 +1,35 @@
+from fastapi import FastAPI
+from fastapi.middleware.cors import CORSMiddleware
+
+from app.api.v1 import admin, auth, chat, cycles, doctors, patients, records, users
+from app.core.settings import settings
+
+
+def create_app() -> FastAPI:
+    app = FastAPI(title=settings.app_name)
+
+    app.add_middleware(
+        CORSMiddleware,
+        allow_origins=settings.cors_origins,
+        allow_credentials=True,
+        allow_methods=["*"],
+        allow_headers=["*"]
+    )
+
+    app.include_router(auth.router, prefix=settings.api_v1_prefix)
+    app.include_router(users.router, prefix=settings.api_v1_prefix)
+    app.include_router(patients.router, prefix=settings.api_v1_prefix)
+    app.include_router(doctors.router, prefix=settings.api_v1_prefix)
+    app.include_router(cycles.router, prefix=settings.api_v1_prefix)
+    app.include_router(records.router, prefix=settings.api_v1_prefix)
+    app.include_router(chat.router, prefix=settings.api_v1_prefix)
+    app.include_router(admin.router, prefix=settings.api_v1_prefix)
+
+    @app.get("/health")
+    async def health() -> dict[str, str]:
+        return {"status": "ok"}
+
+    return app
+
+
+app = create_app()
diff --git a/app/models/__init__.py b/app/models/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..88dace835a35903e57f04c334e656bec970f922a
--- /dev/null
+++ b/app/models/__init__.py
@@ -0,0 +1,22 @@
+from app.models.chat import ChatMessage
+from app.models.cycle import CycleRecord
+from app.models.doctor_profile import DoctorProfile
+from app.models.medical_history import MedicalHistory
+from app.models.medical_record import MedicalRecord
+from app.models.patient_profile import PatientProfile
+from app.models.prescription import Prescription
+from app.models.token_blacklist import TokenBlacklist
+from app.models.user import User, UserRole
+
+__all__ = [
+    "ChatMessage",
+    "CycleRecord",
+    "DoctorProfile",
+    "MedicalHistory",
+    "MedicalRecord",
+    "PatientProfile",
+    "Prescription",
+    "TokenBlacklist",
+    "User",
+    "UserRole",
+]
diff --git a/app/models/chat.py b/app/models/chat.py
new file mode 100644
index 0000000000000000000000000000000000000000..2a62ac85790b11685ce739875f2b17147ec23c15
--- /dev/null
+++ b/app/models/chat.py
@@ -0,0 +1,16 @@
+from sqlalchemy import ForeignKey, String
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class ChatMessage(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "chat_messages"
+
+    sender_id: Mapped[str] = mapped_column(ForeignKey("users.id"), index=True)
+    receiver_id: Mapped[str] = mapped_column(ForeignKey("users.id"), index=True)
+    message: Mapped[str] = mapped_column(String(1000))
+
+    sender = relationship("User", back_populates="sent_messages", foreign_keys=[sender_id])
+    receiver = relationship("User", back_populates="received_messages", foreign_keys=[receiver_id])
diff --git a/app/models/cycle.py b/app/models/cycle.py
new file mode 100644
index 0000000000000000000000000000000000000000..e48efba23ca15c153caa5d399ce6691813f8ca7c
--- /dev/null
+++ b/app/models/cycle.py
@@ -0,0 +1,20 @@
+from datetime import date
+
+from sqlalchemy import Date, ForeignKey, Integer, String
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class CycleRecord(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "cycle_records"
+
+    patient_profile_id: Mapped[str] = mapped_column(ForeignKey("patient_profiles.id"), index=True)
+    cycle_start_date: Mapped[date] = mapped_column(Date, nullable=False)
+    cycle_end_date: Mapped[date | None] = mapped_column(Date, nullable=True)
+    cycle_length: Mapped[int | None] = mapped_column(Integer, nullable=True)
+    flow_intensity: Mapped[str | None] = mapped_column(String(50), nullable=True)
+    symptoms: Mapped[str | None] = mapped_column(String(255), nullable=True)
+
+    patient_profile = relationship("PatientProfile", back_populates="cycles")
diff --git a/app/models/doctor_profile.py b/app/models/doctor_profile.py
new file mode 100644
index 0000000000000000000000000000000000000000..06548d4c5c0bcf8e42c5518f8612ae3e3956368d
--- /dev/null
+++ b/app/models/doctor_profile.py
@@ -0,0 +1,17 @@
+from sqlalchemy import Boolean, ForeignKey, Integer, String
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class DoctorProfile(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "doctor_profiles"
+
+    user_id: Mapped[str] = mapped_column(ForeignKey("users.id"), unique=True, index=True)
+    license_number: Mapped[str | None] = mapped_column(String(120), nullable=True)
+    specialization: Mapped[str | None] = mapped_column(String(120), nullable=True)
+    years_of_experience: Mapped[int | None] = mapped_column(Integer, nullable=True)
+    is_approved: Mapped[bool] = mapped_column(Boolean, default=False)
+
+    user = relationship("User", back_populates="doctor_profile", foreign_keys=[user_id])
diff --git a/app/models/medical_history.py b/app/models/medical_history.py
new file mode 100644
index 0000000000000000000000000000000000000000..4c8d92f6222ae2bbf20c38ebbd5d7ba1cb39f726
--- /dev/null
+++ b/app/models/medical_history.py
@@ -0,0 +1,19 @@
+from sqlalchemy import ForeignKey, String, Text
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class MedicalHistory(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "medical_histories"
+
+    patient_profile_id: Mapped[str] = mapped_column(
+        ForeignKey("patient_profiles.id"), unique=True, index=True
+    )
+    obstetric_history: Mapped[str | None] = mapped_column(String(200), nullable=True)
+    menstrual_history: Mapped[str | None] = mapped_column(Text, nullable=True)
+    contraception_history: Mapped[str | None] = mapped_column(Text, nullable=True)
+    chronic_conditions: Mapped[str | None] = mapped_column(Text, nullable=True)
+
+    patient_profile = relationship("PatientProfile", back_populates="medical_history")
diff --git a/app/models/medical_record.py b/app/models/medical_record.py
new file mode 100644
index 0000000000000000000000000000000000000000..2a22ae093965b2cc98647c52c613f003b8fb0d6b
--- /dev/null
+++ b/app/models/medical_record.py
@@ -0,0 +1,18 @@
+from sqlalchemy import ForeignKey, String
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class MedicalRecord(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "medical_records"
+
+    patient_profile_id: Mapped[str] = mapped_column(ForeignKey("patient_profiles.id"), index=True)
+    doctor_id: Mapped[str] = mapped_column(ForeignKey("doctor_profiles.id"), index=True)
+    diagnosis: Mapped[str | None] = mapped_column(String(255), nullable=True)
+    notes: Mapped[str | None] = mapped_column(String(500), nullable=True)
+
+    patient_profile = relationship("PatientProfile", back_populates="records")
+    doctor = relationship("DoctorProfile", foreign_keys=[doctor_id])
+    prescriptions = relationship("Prescription", back_populates="medical_record")
diff --git a/app/models/mixins.py b/app/models/mixins.py
new file mode 100644
index 0000000000000000000000000000000000000000..5225685aa17a7ef8dff861e011a46e7ad931ead0
--- /dev/null
+++ b/app/models/mixins.py
@@ -0,0 +1,22 @@
+from datetime import datetime, timezone
+from uuid import uuid4
+
+from sqlalchemy import DateTime
+from sqlalchemy.orm import Mapped, mapped_column
+
+
+class UUIDPrimaryKeyMixin:
+    id: Mapped[str] = mapped_column(
+        default=lambda: str(uuid4()), primary_key=True, index=True
+    )
+
+
+class TimestampMixin:
+    created_at: Mapped[datetime] = mapped_column(
+        DateTime(timezone=True), default=lambda: datetime.now(timezone.utc)
+    )
+    updated_at: Mapped[datetime] = mapped_column(
+        DateTime(timezone=True),
+        default=lambda: datetime.now(timezone.utc),
+        onupdate=lambda: datetime.now(timezone.utc),
+    )
diff --git a/app/models/patient_profile.py b/app/models/patient_profile.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a17d34ef9514a253bde60b31a83e06b9f6135fa
--- /dev/null
+++ b/app/models/patient_profile.py
@@ -0,0 +1,25 @@
+from sqlalchemy import Float, ForeignKey, Integer, String
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class PatientProfile(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "patient_profiles"
+
+    user_id: Mapped[str] = mapped_column(ForeignKey("users.id"), unique=True, index=True)
+    age: Mapped[int | None] = mapped_column(Integer, nullable=True)
+    height_cm: Mapped[float | None] = mapped_column(Float, nullable=True)
+    weight_kg: Mapped[float | None] = mapped_column(Float, nullable=True)
+    blood_group: Mapped[str | None] = mapped_column(String(10), nullable=True)
+    marital_status: Mapped[str | None] = mapped_column(String(50), nullable=True)
+    assigned_doctor_id: Mapped[str | None] = mapped_column(
+        ForeignKey("doctor_profiles.id"), nullable=True
+    )
+
+    user = relationship("User", back_populates="patient_profile", foreign_keys=[user_id])
+    assigned_doctor = relationship("DoctorProfile", foreign_keys=[assigned_doctor_id])
+    medical_history = relationship("MedicalHistory", back_populates="patient_profile", uselist=False)
+    cycles = relationship("CycleRecord", back_populates="patient_profile")
+    records = relationship("MedicalRecord", back_populates="patient_profile")
diff --git a/app/models/prescription.py b/app/models/prescription.py
new file mode 100644
index 0000000000000000000000000000000000000000..7de28446cdfe7bfb46025f1cfa77d29ef523557e
--- /dev/null
+++ b/app/models/prescription.py
@@ -0,0 +1,17 @@
+from sqlalchemy import ForeignKey, String
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import UUIDPrimaryKeyMixin
+
+
+class Prescription(Base, UUIDPrimaryKeyMixin):
+    __tablename__ = "prescriptions"
+
+    medical_record_id: Mapped[str] = mapped_column(ForeignKey("medical_records.id"), index=True)
+    medication_name: Mapped[str] = mapped_column(String(255))
+    dosage: Mapped[str] = mapped_column(String(120))
+    frequency: Mapped[str] = mapped_column(String(120))
+    duration: Mapped[str] = mapped_column(String(120))
+
+    medical_record = relationship("MedicalRecord", back_populates="prescriptions")
diff --git a/app/models/token_blacklist.py b/app/models/token_blacklist.py
new file mode 100644
index 0000000000000000000000000000000000000000..b0705cf1957e6440dd4d77d9bfb1283093e65a7c
--- /dev/null
+++ b/app/models/token_blacklist.py
@@ -0,0 +1,13 @@
+from sqlalchemy import Boolean, String
+from sqlalchemy.orm import Mapped, mapped_column
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class TokenBlacklist(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "token_blacklist"
+
+    jti: Mapped[str] = mapped_column(String(64), unique=True, index=True)
+    token_type: Mapped[str] = mapped_column(String(20))
+    revoked: Mapped[bool] = mapped_column(Boolean, default=True)
diff --git a/app/models/user.py b/app/models/user.py
new file mode 100644
index 0000000000000000000000000000000000000000..22908ec173de9fa686489553bdccd53f45379b98
--- /dev/null
+++ b/app/models/user.py
@@ -0,0 +1,32 @@
+from enum import Enum
+
+from sqlalchemy import Boolean, Enum as SqlEnum, String
+from sqlalchemy.orm import Mapped, mapped_column, relationship
+
+from app.db.base import Base
+from app.models.mixins import TimestampMixin, UUIDPrimaryKeyMixin
+
+
+class UserRole(str, Enum):
+    patient = "patient"
+    doctor = "doctor"
+    admin = "admin"
+
+
+class User(Base, UUIDPrimaryKeyMixin, TimestampMixin):
+    __tablename__ = "users"
+
+    name: Mapped[str] = mapped_column(String(200), nullable=False)
+    email: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
+    phone: Mapped[str | None] = mapped_column(String(30), nullable=True)
+    role: Mapped[UserRole] = mapped_column(SqlEnum(UserRole), index=True, nullable=False)
+    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
+    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
+    is_verified: Mapped[bool] = mapped_column(Boolean, default=False)
+
+    patient_profile = relationship("PatientProfile", back_populates="user", uselist=False)
+    doctor_profile = relationship("DoctorProfile", back_populates="user", uselist=False)
+    sent_messages = relationship("ChatMessage", back_populates="sender", foreign_keys="ChatMessage.sender_id")
+    received_messages = relationship(
+        "ChatMessage", back_populates="receiver", foreign_keys="ChatMessage.receiver_id"
+    )
diff --git a/app/schemas/auth.py b/app/schemas/auth.py
new file mode 100644
index 0000000000000000000000000000000000000000..a92b17c43fbca6614f5a1e626ebe9f65b893920b
--- /dev/null
+++ b/app/schemas/auth.py
@@ -0,0 +1,31 @@
+from pydantic import BaseModel, EmailStr, Field
+
+
+class Token(BaseModel):
+    access_token: str
+    refresh_token: str
+    token_type: str = "bearer"
+
+
+class TokenPayload(BaseModel):
+    sub: str
+    type: str
+    jti: str
+
+
+class LoginRequest(BaseModel):
+    email: EmailStr
+    password: str
+
+
+class RefreshRequest(BaseModel):
+    refresh_token: str
+
+
+class PasswordResetRequest(BaseModel):
+    email: EmailStr
+
+
+class PasswordResetConfirm(BaseModel):
+    token: str
+    new_password: str = Field(min_length=8)
diff --git a/app/schemas/chat.py b/app/schemas/chat.py
new file mode 100644
index 0000000000000000000000000000000000000000..9e8864fc6072da413cd96bf32b606cff0879e12f
--- /dev/null
+++ b/app/schemas/chat.py
@@ -0,0 +1,15 @@
+from pydantic import BaseModel
+
+
+class ChatMessageCreate(BaseModel):
+    receiver_id: str
+    message: str
+
+
+class ChatMessageRead(BaseModel):
+    id: str
+    sender_id: str
+    receiver_id: str
+    message: str
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/common.py b/app/schemas/common.py
new file mode 100644
index 0000000000000000000000000000000000000000..6cf2f4fa51e041b84b123e80a0eee39621dc3baa
--- /dev/null
+++ b/app/schemas/common.py
@@ -0,0 +1,10 @@
+from datetime import datetime
+
+from pydantic import BaseModel
+
+
+class TimestampSchema(BaseModel):
+    created_at: datetime
+    updated_at: datetime
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/cycle.py b/app/schemas/cycle.py
new file mode 100644
index 0000000000000000000000000000000000000000..625124afc180a12670e947e5630687c6da06a927
--- /dev/null
+++ b/app/schemas/cycle.py
@@ -0,0 +1,22 @@
+from datetime import date
+
+from pydantic import BaseModel
+
+
+class CycleBase(BaseModel):
+    cycle_start_date: date
+    cycle_end_date: date | None = None
+    cycle_length: int | None = None
+    flow_intensity: str | None = None
+    symptoms: str | None = None
+
+
+class CycleCreate(CycleBase):
+    pass
+
+
+class CycleRead(CycleBase):
+    id: str
+    patient_profile_id: str
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/doctor.py b/app/schemas/doctor.py
new file mode 100644
index 0000000000000000000000000000000000000000..795b3fa52894b088b69984f18673b50566c77bcc
--- /dev/null
+++ b/app/schemas/doctor.py
@@ -0,0 +1,19 @@
+from pydantic import BaseModel
+
+
+class DoctorProfileBase(BaseModel):
+    license_number: str | None = None
+    specialization: str | None = None
+    years_of_experience: int | None = None
+    is_approved: bool | None = None
+
+
+class DoctorProfileCreate(DoctorProfileBase):
+    pass
+
+
+class DoctorProfileRead(DoctorProfileBase):
+    id: str
+    user_id: str
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/medical_history.py b/app/schemas/medical_history.py
new file mode 100644
index 0000000000000000000000000000000000000000..760c9c19b9d2788a643505ff24ee02000554219c
--- /dev/null
+++ b/app/schemas/medical_history.py
@@ -0,0 +1,19 @@
+from pydantic import BaseModel
+
+
+class MedicalHistoryBase(BaseModel):
+    obstetric_history: str | None = None
+    menstrual_history: str | None = None
+    contraception_history: str | None = None
+    chronic_conditions: str | None = None
+
+
+class MedicalHistoryCreate(MedicalHistoryBase):
+    pass
+
+
+class MedicalHistoryRead(MedicalHistoryBase):
+    id: str
+    patient_profile_id: str
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/patient.py b/app/schemas/patient.py
new file mode 100644
index 0000000000000000000000000000000000000000..d7a67c3f05d23a72ca3ff3cd23ebd88bb22adb0d
--- /dev/null
+++ b/app/schemas/patient.py
@@ -0,0 +1,25 @@
+from pydantic import BaseModel
+
+
+class PatientProfileBase(BaseModel):
+    age: int | None = None
+    height_cm: float | None = None
+    weight_kg: float | None = None
+    blood_group: str | None = None
+    marital_status: str | None = None
+    assigned_doctor_id: str | None = None
+
+
+class PatientProfileCreate(PatientProfileBase):
+    pass
+
+
+class PatientProfileUpdate(PatientProfileBase):
+    pass
+
+
+class PatientProfileRead(PatientProfileBase):
+    id: str
+    user_id: str
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/prescription.py b/app/schemas/prescription.py
new file mode 100644
index 0000000000000000000000000000000000000000..828538d6417dc957378359c387ff70f8e36a14ea
--- /dev/null
+++ b/app/schemas/prescription.py
@@ -0,0 +1,19 @@
+from pydantic import BaseModel
+
+
+class PrescriptionBase(BaseModel):
+    medication_name: str
+    dosage: str
+    frequency: str
+    duration: str
+
+
+class PrescriptionCreate(PrescriptionBase):
+    medical_record_id: str
+
+
+class PrescriptionRead(PrescriptionBase):
+    id: str
+    medical_record_id: str
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/record.py b/app/schemas/record.py
new file mode 100644
index 0000000000000000000000000000000000000000..3e7282c2e4baa63f26ff6f213ad9698108b2fcf0
--- /dev/null
+++ b/app/schemas/record.py
@@ -0,0 +1,18 @@
+from pydantic import BaseModel
+
+
+class MedicalRecordBase(BaseModel):
+    diagnosis: str | None = None
+    notes: str | None = None
+
+
+class MedicalRecordCreate(MedicalRecordBase):
+    patient_id: str
+
+
+class MedicalRecordRead(MedicalRecordBase):
+    id: str
+    patient_profile_id: str
+    doctor_id: str
+
+    model_config = {"from_attributes": True}
diff --git a/app/schemas/user.py b/app/schemas/user.py
new file mode 100644
index 0000000000000000000000000000000000000000..33a3bc38c1511897c1b716b96c0d3d5e6f585f42
--- /dev/null
+++ b/app/schemas/user.py
@@ -0,0 +1,30 @@
+from pydantic import BaseModel, EmailStr, Field
+
+from app.models.user import UserRole
+
+
+class UserBase(BaseModel):
+    name: str
+    email: EmailStr
+    phone: str | None = None
+
+
+class UserCreate(UserBase):
+    password: str = Field(min_length=8)
+    role: UserRole
+
+
+class UserRead(UserBase):
+    id: str
+    role: UserRole
+    is_active: bool
+    is_verified: bool
+
+    model_config = {"from_attributes": True}
+
+
+class UserUpdate(BaseModel):
+    name: str | None = None
+    phone: str | None = None
+    is_active: bool | None = None
+    is_verified: bool | None = None
diff --git a/app/services/auth.py b/app/services/auth.py
new file mode 100644
index 0000000000000000000000000000000000000000..e07e9aa7ec0e283fb74c9fae82ea137a0111b41a
--- /dev/null
+++ b/app/services/auth.py
@@ -0,0 +1,63 @@
+from datetime import timedelta
+
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.core.security import create_token, hash_password, verify_password
+from app.core.settings import settings
+from app.models.token_blacklist import TokenBlacklist
+from app.models.user import User, UserRole
+
+
+async def get_user_by_email(session: AsyncSession, email: str) -> User | None:
+    result = await session.execute(select(User).where(User.email == email))
+    return result.scalar_one_or_none()
+
+
+async def create_user(
+    session: AsyncSession, name: str, email: str, password: str, role: UserRole, phone: str | None
+) -> User:
+    user = User(
+        name=name,
+        email=email,
+        phone=phone,
+        role=role,
+        hashed_password=hash_password(password),
+        is_active=True,
+        is_verified=role == UserRole.patient,
+    )
+    session.add(user)
+    await session.commit()
+    await session.refresh(user)
+    return user
+
+
+async def authenticate_user(session: AsyncSession, email: str, password: str) -> User | None:
+    user = await get_user_by_email(session, email)
+    if not user:
+        return None
+    if not verify_password(password, user.hashed_password):
+        return None
+    if not user.is_active:
+        return None
+    return user
+
+
+def build_tokens(user: User) -> tuple[str, str, str]:
+    access_token, access_jti = create_token(
+        subject=user.id,
+        token_type="access",
+        expires_delta=timedelta(minutes=settings.access_token_expire_minutes),
+    )
+    refresh_token, refresh_jti = create_token(
+        subject=user.id,
+        token_type="refresh",
+        expires_delta=timedelta(days=settings.refresh_token_expire_days),
+    )
+    return access_token, refresh_token, refresh_jti
+
+
+async def revoke_token(session: AsyncSession, jti: str, token_type: str) -> None:
+    record = TokenBlacklist(jti=jti, token_type=token_type, revoked=True)
+    session.add(record)
+    await session.commit()
diff --git a/docker-compose.yml b/docker-compose.yml
index 4de41ae35e226432a1a4a7c1ad4191923afe1da3..6156ba6969e1a6dd4cff836fff25a0aa0247bf14 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,14 +1,15 @@
+version: "3.9"
 
-version: '3'
 services:
-  web:
+  app:
     build: .
-    ports: ["5000:5000"]
-    env_file: .env
-    depends_on: [db]
-  db:
-    image: postgres:15
-    environment:
-      POSTGRES_USER: gynos
-      POSTGRES_PASSWORD: gynos
-      POSTGRES_DB: gynos
+    ports:
+      - "8000:8000"
+    env_file:
+      - .env
+
+  test:
+    build: .
+    command: pytest -q
+    env_file:
+      - .env
diff --git a/mygyno_source.tar.gz b/mygyno_source.tar.gz
new file mode 100644
index 0000000000000000000000000000000000000000..39d8dcd6371c260f46b407f0325d79d8e7bc9aa2
GIT binary patch
literal 13608
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

literal 0
HcmV?d00001

diff --git a/offline_archive.txt b/offline_archive.txt
new file mode 100644
index 0000000000000000000000000000000000000000..9308e112f5da5a3c0fd9e928bb5c5231ca1c906e
--- /dev/null
+++ b/offline_archive.txt
@@ -0,0 +1 @@
+Offline archive: mygyno_source.tar.gz
diff --git a/requirements.txt b/requirements.txt
index 67d6f4c6b9706e881b135bccb0235b24f0c6d90f..3e9bea63f80ec15af6141cfc289e1acbdc9baff4 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,2 +1,13 @@
-flask==3.0.0
-gunicorn==21.2.0
+fastapi==0.110.0
+uvicorn[standard]==0.27.1
+sqlalchemy==2.0.27
+alembic==1.13.1
+pydantic==2.6.1
+python-jose==3.3.0
+passlib[bcrypt]==1.7.4
+aiosqlite==0.20.0
+asyncpg==0.29.0
+pydantic-settings==2.5.2
+
+pytest==8.0.0
+pytest-asyncio==0.23.5
diff --git a/run.py b/run.py
index 6a943c32b44891889982f1f3a8a7260bfc7de8c7..5540167f8e46a5c148e9e905593f14ad5fa9e7e9 100644
--- a/run.py
+++ b/run.py
@@ -1,6 +1,7 @@
-from app import create_app
+import uvicorn
+
+from app.main import app
 
-app = create_app()
 
 if __name__ == "__main__":
-    app.run(host="0.0.0.0", port=5000)
+    uvicorn.run(app, host="0.0.0.0", port=8000)
diff --git a/run_tests.sh b/run_tests.sh
new file mode 100755
index 0000000000000000000000000000000000000000..5a56606708a831738ed0cf50add487f718acbf7d
--- /dev/null
+++ b/run_tests.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+set -e
+
+echo "🔨 Building Docker images..."
+docker-compose build
+
+echo "🧪 Running tests inside Docker..."
+docker-compose run --rm test
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..124165b121bdcdc5f3d9e57135e2987e1b4b7d9d
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,41 @@
+import asyncio
+
+import pytest
+from fastapi.testclient import TestClient
+from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine
+from sqlalchemy.pool import StaticPool
+
+from app.db.base import Base
+from app.db.session import get_db
+from app.main import create_app
+
+
+@pytest.fixture(scope="session")
+def test_engine():
+    engine = create_async_engine(
+        "sqlite+aiosqlite:///:memory:",
+        connect_args={"check_same_thread": False},
+        poolclass=StaticPool,
+    )
+    asyncio.run(_create_tables(engine))
+    yield engine
+    asyncio.run(engine.dispose())
+
+
+async def _create_tables(engine) -> None:
+    async with engine.begin() as conn:
+        await conn.run_sync(Base.metadata.create_all)
+
+
+@pytest.fixture()
+def client(test_engine):
+    app = create_app()
+    async_session = async_sessionmaker(test_engine, expire_on_commit=False)
+
+    async def override_get_db():
+        async with async_session() as session:
+            yield session
+
+    app.dependency_overrides[get_db] = override_get_db
+    with TestClient(app) as test_client:
+        yield test_client
diff --git a/tests/test_auth.py b/tests/test_auth.py
new file mode 100644
index 0000000000000000000000000000000000000000..e0964437d9a2239cec31f321f802a8c1be444433
--- /dev/null
+++ b/tests/test_auth.py
@@ -0,0 +1,25 @@
+def test_register_login_refresh(client):
+    register_payload = {
+        "name": "Patient One",
+        "email": "patient@example.com",
+        "phone": "123",
+        "password": "strongpassword",
+        "role": "patient",
+    }
+    response = client.post("/api/v1/auth/register", json=register_payload)
+    assert response.status_code == 201
+
+    login_response = client.post(
+        "/api/v1/auth/login", json={"email": "patient@example.com", "password": "strongpassword"}
+    )
+    assert login_response.status_code == 200
+    tokens = login_response.json()
+    assert "access_token" in tokens
+    assert "refresh_token" in tokens
+
+    refresh_response = client.post(
+        "/api/v1/auth/refresh", json={"refresh_token": tokens["refresh_token"]}
+    )
+    assert refresh_response.status_code == 200
+    refreshed = refresh_response.json()
+    assert refreshed["access_token"]
diff --git a/tests/test_rbac.py b/tests/test_rbac.py
new file mode 100644
index 0000000000000000000000000000000000000000..e95eb22976bbdfd9b1563e0956fa95d73554f769
--- /dev/null
+++ b/tests/test_rbac.py
@@ -0,0 +1,17 @@
+def test_patient_cannot_list_users(client):
+    client.post(
+        "/api/v1/auth/register",
+        json={
+            "name": "Patient",
+            "email": "patient2@example.com",
+            "phone": "555",
+            "password": "strongpassword",
+            "role": "patient",
+        },
+    )
+    login_response = client.post(
+        "/api/v1/auth/login", json={"email": "patient2@example.com", "password": "strongpassword"}
+    )
+    token = login_response.json()["access_token"]
+    response = client.get("/api/v1/users/", headers={"Authorization": f"Bearer {token}"})
+    assert response.status_code == 403
 
EOF
)
